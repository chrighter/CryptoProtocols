import random
from collections import namedtuple

D = 0
KEY_LENGTH = 0
N = 0

class PrivKey(namedtuple('PrivKey', 'n d')):
    __slots__ = ()

    def sign(self, x):
        return self.decrypt(x)

    def decrypt(self, x):
        return pow(x, self.d) % self.n


def get_gcd(x, y): 
    if x > y: 
        small = y 
    else: 
        small = x 
    for i in range(1, small+1): 
        if((x % i == 0) and (y % i == 0)): 
            gcd = i 
              
    return gcd 


class PublKey(namedtuple('publKey', 'n e')):
    __slots__ = ()

    def encrypt(self, x):
        return pow(x, self.e, self.n)

    def blind(self, m):
        factor = int(random.random() * (self.n - 1))

        while get_gcd(factor, self.n) != 1:
            factor = int(random.random() * (self.n - 1))

        return (m * factor ** self.e) % self.n, factor

    def unblind(self, b, factor):
        return (b * inverse(factor ** self.e, self.n)) % self.n


def get_keys(key_length):
    if key_length < 4:
        raise ValueError('Key length too short')

    n_min = 1 << (key_length - 1)
    n_max = (1 << key_length) - 1

    start = 1 << (key_length // 2 - 1)
    stop = 1 << (key_length // 2 + 1)
    primes = get_primes(start, stop)

    while primes:
        p = random.choice(primes)
        primes.remove(p)
        q_candidates = [q for q in primes
                        if n_min <= p * q <= n_max]
        if q_candidates:
            q = random.choice(q_candidates)
            break
    else:
        raise AssertionError("Can't find 'p' and 'q' for this key")

    stop = (p - 1) * (q - 1)
    for e in range(3, stop, 2):
        if are_relatively_prime(e, stop):
            break
    else:
        raise AssertionError("Can't find 'e' with current p and q")

    for d in range(3, stop, 2):
        if d * e % stop == 1:
            break
    else:
        raise AssertionError("cannot find 'd' with current p and q and e=")

    return PublKey(p * q, e), PrivKey(p * q, d)


def get_primes(start, stop):
    if start >= stop:
        return []

    primes = [2]

    for n in range(3, stop + 1, 2):
        for p in primes:
            if n % p == 0:
                break
        else:
            primes.append(n)

    while primes and primes[0] < start:
        del primes[0]

    return primes


def are_relatively_prime(a, b):
    for n in range(2, min(a, b) + 1):
        if a % n == b % n == 0:
            return False

    return True


def inverse(value, modulus):
    x, last_x = 0, 1
    a, b = modulus, value

    while b:
        a, q, b = b, a // b, a % b
        x, last_x = last_x - q * x, x

    result = (1 - last_x * modulus) // value

    if result < 0:
        result += modulus

    return result


def get_bob_documents(n, d, bob_pub):
    documents = []

    for i in range(n):
        documents.append(bob_pub.blind(d))

    return documents


def bank_validate(validating_documents, bob_pub, d):
    for message, factor in validating_documents:
        assert bob_pub.unblind(message, factor) == d


def output(docs, bank_sec, D):
    print('The bank signs document #n ...')
    message, _ = docs[-1]
    print('Signed {0} is:'.format(D))
    print(bank_sec.sign(message))


def initialize():
    KEY_LENGTH = 8

    print('Input signed number')
    D = int(input())

    print('Input counts of documents generated by Bob')
    N = int(input())

    return KEY_LENGTH, D, N


def main():
    KEY_LENGTH, D, N = initialize()
    bank_pub, bank_sec = get_keys(KEY_LENGTH)
    bob_pub, bob_sec = get_keys(KEY_LENGTH)

    docs = get_bob_documents(N, D, bob_pub)
    bank_validate(docs[:-1], bob_pub, D)
    output(docs, bank_sec, D)


if __name__ == '__main__':
    main()
